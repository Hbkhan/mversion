#!/usr/bin/env node

var argv = process.argv.slice(2),
    chalk = require('chalk'),
    path = require('path'),
    version = require('../version'),
    thisVersion = require('../package.json').version;

var parsedArguments = require('minimist')(argv, {
  'string': ['t', 'tag'],
  'boolean': ['n']
});
var defaultMessage = "v%s";

if (argv.length === 0) {
  get();
} else {
  update();
}

function get() {
  version.get(function (err, data) {
    if (err) {
      console.error(chalk.red(err.message));
    }

    for(file in data) {
      if (data[file]) {
        console.log(chalk.green(file) + ': ' + chalk.yellow(data[file]));
      }
    }

    if (err) process.exit(1);
  });
}

function update () {
  var updateOptions = {
    version: parsedArguments._[0],
    noPrefix: !!parsedArguments.n || parsedArguments.prefix === false
  };

  if (isArgumentPassed('h', 'help', '?')) {
    usage();
    process.exit(0);
  }

  if (isArgumentPassed('v', 'version')) {
    console.log('mversion v' + thisVersion);
    process.exit(0);
  }

  // Check for git:
  if (isArgumentPassed('m')) {
    updateOptions.commitMessage =
      parsedArguments.m === true
        ? defaultMessage
        : parsedArguments.m;
  }

  // Check for overriding tag name
  if (isArgumentPassed('t', 'tag')) {
    updateOptions.tagName = parsedArguments.t || parsedArguments.tag;
  }

  version.update(updateOptions, function (err, data) {
    if (err) {
      console.error(chalk.red('Failed updating:'));

      if (!data) {
        console.error(err.message);
      } else {
        console.error(constructError(
          err.message,
          data.updatedFiles,
          updateOptions.commitMessage,
          updateOptions.noPrefix,
          data.newVersion
        ));
      }
      process.exit(1);
    }

    if (data && data.newVersion) {
      console.log(chalk.green('Updated to new version: ') + chalk.yellow('v' + data.newVersion));
      console.log(data.message);
    }
  });
}

function usage () {
  console.log([
                chalk.bold(chalk.green("Usage:")) + chalk.yellow(" mversion [ <newversion> | major | minor | patch | prerelease ] [ -m <optional message> ] [ -n | --no-prefix ]"),
                chalk.underline("(run in package dir) - (Also supports premajor, preminor and prepatch, see semver summary)"),

                "",
                "Update module version in either one or all of package.json,",
                "component.json, bower.json, manifest.json and *.jquery.json.",

                "",
                "Run without arguments to get current version.",
                "",

                chalk.bold(chalk.green("# Semver Summary")),
                "Given a version number " + chalk.yellow("MAJOR.MINOR.PATCH") + ", increment the:",
                "- " + chalk.yellow("MAJOR") + " version when you make incompatible API changes,,",
                "- " + chalk.yellow("MINOR") + " version when you add functionality in a backwards-compatible manner, and,",
                "- " + chalk.yellow("PATCH") + " version when you make backwards-compatible bug fixes.,",
                "Additional labels for pre-release and build metadata are available as extensions to the " + chalk.yellow("MAJOR.MINOR.PATCH") + " format.,",
                "",

                chalk.bold(chalk.green("# Update version")),
                "Update version by defining new semver valid version ",
                "or a release string (major, minor, patch, build).",
                "--",
                "Ex: \"mversion minor\"",
                "Ex: \"mversion 1.0.1-beta\"",
                "--",
                "",

                chalk.bold(chalk.green("# Git")),
                "Use " + chalk.yellow("-m") + " to auto commit and tag. Apply optional message and ",
                "use '" + chalk.magenta("%s") + "' as placeholder for the updated version. Default ",
                "message is 'v" + chalk.magenta("%s") + "' where " + chalk.magenta("%s") + " is replaced with new version.",
                "",


                chalk.yellow("--tag") + " (or " + chalk.yellow("-t") + " for short) allows for overriding the tag name used. This does not",
                "change behaviour of the message, just the tag name. As with " + chalk.yellow("-m") + ", all occurances of " + chalk.magenta("%s"),
                "is replaced with the newly bumped version.",
                "",

                chalk.yellow("--no-prefix") + " (or " + chalk.yellow("-n") + " for short) is a short hand for setting",
                "a tag name without v as prefix. This does not change behaviour of",
                "the message, just the tag name.",
                "",
                "--",
                "Ex: \"mversion minor -m\"",
                "Ex: \"mversion minor -m 'Bumped to v%s' --tag 'v%s-src'\"",
                "--",
                ""
              ].join("\n"))
}

function isArgumentPassed () {
  var args = Array.prototype.slice.apply(arguments);
  for(var i = 0, len = args.length; i < len; i++) {
    if (!!parsedArguments[args[i]]) {
      return true;
    }
  }
  return false;
}

function constructError (errors, files, commitMessage, isNoPrefix, updatedVersion) {
  var commitFlag = commitMessage ? '-m "' + commitMessage + '"' : '';
  var noPrefixFlag = isNoPrefix ? '--no-prefix' : '';

  var ret = 'Some files contains errors:\n';

  ret += chalk.red(errors);

  if (files && files.length) {
    ret += '\n\nOther files (' + files.map(function (file) {
          return chalk.green(path.basename(file));
        }).join(', ') + ') got updated to version ' + chalk.yellow('v' + updatedVersion) + '.\n\n';
  }

  if (!!commitMessage) {
    ret += '\nThe changes were not commited, as there were errors.\n';
  }

  ret += 'Fix erros and try again to synchronize:\n';
  ret += chalk.bold(chalk.yellow(['$ mversion', updatedVersion, commitFlag, noPrefixFlag].join(' ')));
  return ret;
}